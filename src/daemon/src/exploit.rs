use std::thread::spawn;
use std::sync::mpsc;

use nix::{sys::ptrace, sys::{wait, signal::Signal::SIGTRAP}, unistd::Pid, errno::Errno::ECHILD};
use procfs::process::{MMapPath, all_processes};

use crate::packet_id::{to_exploit_packets, to_main_packets};
use crate::packet::{ToExploitPacket, ToMainPacket};
use crate::score::Score;

const DRAW_SCOREBOARD_OFFSET: u64 = 0x1f80;

pub struct Exploit {
    pub attached: bool,
    pub to_exploit_sender: Option<mpsc::Sender<ToExploitPacket>>,
    pub to_main_receiver: Option<mpsc::Receiver<ToMainPacket>>
}

impl Exploit {
    pub fn new() -> Exploit {
        Exploit {
            attached: false,
            to_exploit_sender: None,
            to_main_receiver: None
        }
    }
    pub fn attach(&mut self) -> Result<(), ()> {
        let mut pid: Option<Pid> = None;
        let mut base_address: Option<u64> = None;

        for proc in all_processes().unwrap() {
            if proc.stat.comm == "Pong C" {
                pid = Some(Pid::from_raw(proc.pid));
                let maps = proc.maps().unwrap();

                for map in maps {
                    if let MMapPath::Path(path) = map.pathname {
                        if path.file_name().unwrap() == "Pong C" && map.offset == 0 {
                            base_address = Some(map.address.0);
                        }
                    }
                }
            }
        }

        if pid.is_none() || base_address.is_none() {
            return Err(());
        }

        let (to_exploit_sender, to_exploit_receiver) = mpsc::channel::<ToExploitPacket>();
        let (to_main_sender, to_main_receiver) = mpsc::channel::<ToMainPacket>();

        spawn(move || {
            let pid = pid.unwrap();
            let base_address = base_address.unwrap();

            ptrace::attach(pid).unwrap();

            wait::waitpid(pid, Some(wait::WaitPidFlag::WUNTRACED)).unwrap();

            let draw_scoreboard_address = (base_address + DRAW_SCOREBOARD_OFFSET) as *mut libc::c_void;

            let data = ptrace::read(pid, draw_scoreboard_address).unwrap();

            let original = (data & 0xff) as *mut libc::c_void;
            let breakpoint = ((data & !0xff) | 0xcc) as *mut libc::c_void;

            unsafe {
                ptrace::write(pid, draw_scoreboard_address, breakpoint).unwrap();
            }

            ptrace::cont(pid, None).unwrap();

            let mut fake_score = Score::new(0, 0);
            let mut real_score = Score::new(0, 0);

            let mut should_detach = false;
            let mut exit_after_detach = false;
            let mut already_fetched_original_scores = false;

            loop {
                if let Ok(packet) = to_exploit_receiver.try_recv() {
                    match packet.id {
                        to_exploit_packets::CHANGE_LEFT_SCORE => {
                            fake_score.left_score = packet.score.unwrap();
                        },
                        to_exploit_packets::CHANGE_RIGHT_SCORE => {
                            fake_score.right_score = packet.score.unwrap();
                        },
                        to_exploit_packets::GET_LEFT_SCORE => {
                            to_main_sender.send(
                                ToMainPacket::new(
                                    to_main_packets::LEFT_SCORE,
                                    Some(fake_score.left_score)
                                )
                            ).unwrap();
                        },
                        to_exploit_packets::GET_RIGHT_SCORE => {
                            to_main_sender.send(
                                ToMainPacket::new(
                                    to_main_packets::RIGHT_SCORE,
                                    Some(fake_score.right_score)
                                )
                            ).unwrap();
                        },
                        to_exploit_packets::DETACH => {
                            should_detach = true;
                        },
                        to_exploit_packets::DETACH_AND_EXIT => {
                            should_detach = true;
                            exit_after_detach = true;
                        },
                        _ => {
                            panic!("unknown ToExploitPacket: {}", packet.id);
                        }
                    }
                }

                match wait::waitpid(pid, Some(wait::WaitPidFlag::WUNTRACED)) {
                    Ok(wait::WaitStatus::Stopped(pid, signal)) => {
                        if signal == SIGTRAP {
                            if should_detach {
                                let restored = ((data & !0xff) | original as i64) as *mut libc::c_void;
                                unsafe {
                                    ptrace::write(pid, draw_scoreboard_address, restored).unwrap();
                                }

                                if exit_after_detach {
                                    std::process::exit(0);
                                } else {
                                    to_main_sender.send(
                                        ToMainPacket::new(
                                            to_main_packets::DETACHED,
                                            None
                                        )
                                    ).unwrap();

                                    break;
                                }
                            } else {
                                let mut registers = ptrace::getregs(pid).unwrap();

                                if already_fetched_original_scores {
                                    if registers.rdi as i32 > real_score.left_score {
                                        fake_score.left_score += 1;
                                    }
                                    if registers.rsi as i32 > real_score.right_score {
                                        fake_score.right_score += 1;
                                    }

                                    fake_score.left_score = fake_score.left_score.clamp(0, 999_999);
                                    fake_score.right_score = fake_score.right_score.clamp(0, 999_999);

                                    real_score.left_score = registers.rdi as i32;
                                    real_score.right_score = registers.rsi as i32;

                                    registers.rdi = fake_score.left_score as u64;
                                    registers.rsi = fake_score.right_score as u64;

                                } else {
                                    real_score.left_score = registers.rdi as i32;
                                    real_score.right_score = registers.rsi as i32;

                                    fake_score.left_score = registers.rdi as i32;
                                    fake_score.right_score = registers.rsi as i32;

                                    already_fetched_original_scores = true;
                                }

                                ptrace::setregs(pid, registers).unwrap();
                            }
                        }

                        ptrace::cont(pid, None).unwrap();
                    },
                    Err(ECHILD) => {
                        to_main_sender.send(
                            ToMainPacket::new(
                                to_main_packets::GAME_EXITED,
                                None
                            )
                        ).unwrap();

                        return;
                    },
                    _ => {}
                }
            }
        });

        self.to_exploit_sender = Some(to_exploit_sender);
        self.to_main_receiver = Some(to_main_receiver);

        self.attached = true;

        Ok(())
    }
}
